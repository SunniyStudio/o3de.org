---
linkTitle: 第32章 Auto组件
title: 第32章 Auto组件
description: 第32章 Auto组件
---
# 第32章 Auto组件
##  Introduction

{{<note>}}
The accompanying source code and assets for this chapter can be found on GitHub at:
https://github.com/AMZN-Olex/O3DEBookCode2111/tree/ch32_auto_components
{{</note>}}

In O3DE multiplayer components are code generated from their XML definitions, such as MyFirstNetworkComponent.AutoComponent.xml in the previous chapter. An auto-component is a code generated multiplayer component. This chapter will cover enough theory of auto-components to get us through the rest of multiplayer chapters.

* How does one create a new multiplayer component? 
* What is a Controller? 
* What is a (network) Component? 
* Where are code generated classes created? 
* Overriding base classes of controllers and components.

{{<note>}}
In this section of the book, multiplayer and network terms are used interchangeably.
{{</note>}}

##  Code Generation
Example 32.1. An auto-component
```xml
<?xml version="1.0"?>
<Component
  Name="MyFirstNetworkComponent"
  Namespace="MyGem"
  OverrideComponent="false"
  OverrideController="false"
  OverrideInclude=""
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
</Component>
```

Given the above XML definition the following files will be produced for you:
* MyFirstNetworkComponent.AutoComponent.h 
* MyFirstNetworkComponent.AutoComponent.cpp

These files are placed inside the build code-generation section, such as C:\git\book\build\External\MyGem-409da4e6\ Code\Azcg\Generated\Source\AutoGen\MyFirstNetworkComponent.AutoComponent.h.

{{<tip>}}
Your specific build path might be different but if you search within your build folder for these components you will find them.
{{</tip>}}

In general, you should not pay too much attention to these files but you should know that they provide the backbone of multiplayer functionality of your components as well as various Editor and script reflection.

Code generated headers (*.AutoComponent.h) declare two important classes: a Component and a Controller.

##  Components and Controllers
In the context of multiplayer components, their Controllers have write access to component's state, while their Components have read-only access. On clients, a component will be without a controller and thus unable to modify its data directly. Changes can be made on the server where a controller is available.

{{<note>}}
There is one exception for autonomous entities, such as player entities, that need to be able to locally predict themselves. In such a case, there is a controller on a client as well but only for the player entity that the client controls. I cover this unique case in Chapter 40, Multiplayer Camera.
{{</note>}}

Figure 32.1. Components and Controllers

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_1.PNG)

Where do these controllers and components come from? They are created by the code generator we have configured in previous chapter. An XML definition is the root source that defines the data and basic structure of a multiplayer component.

Look at the top of MyFirstNetworkComponent.AutoComponent.h for a useful comment describing the current configuration of the component and your options.
```c++
// No component roles have been overridden.  You can modify
// MyFirstNetworkComponent.AutoComponent.xml to specify derived
// classes for your desired network role.
// Once your modifications are complete, build the game. Your build
// will fail, but this comment will be replaced with a stub that
 // can be used as the basis for your derived component roles.
```

Figure 32.2. Overview of Code Generation of Auto-components

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_2.PNG)

## Overriding Components and Controllers
As the comment from the code generated header file stated, you can override your component and controller. A good rule of thumb is that if you wish to provide server-specific logic, then you will want to override the controller using the following XML property:
```
OverrideController="true"
```

If you wish to provide client-specific logic, then override the component with:
```
OverrideComponent="true"
```

Here is example of a component that overrides both the component and the controller.
```
<?xml version="1.0"?>
<Component
  Name="MyFirstNetworkComponent"
  Namespace="MyGem"
  OverrideComponent="true"
  OverrideController="true"
  OverrideInclude="Source/MyFirstNetworkComponent.h"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
</Component>
```

## Creating Your Own Controllers
Just about any new network component you create will need three (3) files in your project regardless of what code generation magic does in the build folder. Here are these files:
1. XML auto-component definition, MyFirstNetworkComponent.AutoComponent.xml
2. Header file, MyFirstNetworkComponent.h.
3. Source file, MyFirstNetworkComponent.cpp.
 
Here are the steps on writing network component code once you have an XML definition.

1. Create an XML definition that overrides either the component or the controller or both.
```
OverrideController="true"
```

2. Specify OverrideInclude with the path to the header file where your own game logic will be written. This path is relative to the gem's location at C:\git\book\Gems\MyGem\Code\Source.
```
OverrideInclude="Multiplayer\MyFirstNetworkComponent.h"
```
This will expect to find a file at C:\git\book\Gems\MyGem\Code\Source\Multiplayer\MyFirstNetworkComponent.h.
{{<note>}}
Adding Multiplayer folder is optional. You can create your own folder structure or no folder at all and place your source code directly under Source, in which case OverrideInclude wouldbe:
```
OverrideInclude="MyFirstNetworkComponent.h"
```
{{</note>}}

3. Create an empty MyFirstNetworkComponent.h and MyFirstNetworkComponent.cpp.
4. Add references to these files to the file list.

Example 32.2. mygem_files.cmake with an auto-component
```
set(FILES
  ...
  # new
  Source/AutoGen/MyFirstNetworkComponent.AutoComponent.xml
  Source/Multiplayer/MyFirstNetworkComponent.h
  Source/Multiplayer/MyFirstNetworkComponent.cpp
)
```
5. Build MyGem.static target.

{{<note>}}
If neither a component nor a controller was overridden then you can skip the rest of the steps. The component will appear in the Editor but will not be particularly useful, since it will not possess any game logic.
{{</note>}}

6. You will get a lot of build errors but look for the errors that mention MyFirstNetworkCompo nent.AutoComponent.h. In Visual Studio you can double click on the error and jump to the generated header. Or navigate there by looking up the path in the build log.

7. Open MyFirstNetworkComponent.AutoComponent.h.
8. Look for the first big comment block at the top of the header file. The comment block with start with "You may use the classes below as a basis for your new derived classes." The rest of the comment block will provide you with stubs for the header and source file.
9. Copy the code from "/// Place in your .h" to "/// Place in your .cpp" into
MyFirstNetworkComponent.h.
10. Copy the rest of the comment to MyFirstNetworkComponent.cpp.
11. Compile the project again. Everything should compile cleanly.

Example 32.3. Provided Stub of MyFirstNetworkComponent.h
```c++
 #pragma once
 #include <Source/AutoGen/MyFirstNetworkComponent.AutoComponent.h>
 namespace MyGem
 {
    class MyFirstNetworkComponentController
        :  public MyFirstNetworkComponentControllerBase
    {
     public:
            MyFirstNetworkComponentController(                MyFirstNetworkComponent& parent);
       void OnActivate(Multiplayer::EntityIsMigrating) override;
       void OnDeactivate(Multiplayer::EntityIsMigrating) override;
     protected:
    };
 }
```

MyFirstNetworkComponentController is a controller but its interface is very similar to AZ::Component.
* OnActivate plays the same role as Activate does on a regular component.
* OnDeactivate plays the same role as Deactivate does on a regular component.

Example 32.4. Provided Stub of MyFirstNetworkComponent.cpp
```c++
#include <Multiplayer/MyFirstNetworkComponent.h>
 #include <AzCore/Serialization/SerializeContext.h>
 namespace MyGem
 {
    MyFirstNetworkComponentController::
      MyFirstNetworkComponentController(MyFirstNetworkComponent& p)
        : MyFirstNetworkComponentControllerBase(p)
    {
    }
 void MyFirstNetworkComponentController::OnActivate(
        Multiplayer::EntityIsMigrating)
    {
    }
 void MyFirstNetworkComponentController::OnDeactivate(
     Multiplayer::EntityIsMigrating)
    {
    }
 }
```

{{<note>}}
There is a reference here to MyFirstNetworkComponent. This component was generated for us by Multiplayer gem code generator. This component is already reflected and registered with the engine.
{{</note>}}

Even though the code above does not look like much, it comes with a lot power underneath by deriving from MyFirstNetworkComponentControllerBase. For example, the controller can at any time access its component by GetParent() or get the entity pointer the controller is on with GetEntity().

Example 32.5. Accessing the Entity from a Controller
```c++
 void MyFirstNetworkComponentController::OnActivate(
        Multiplayer::EntityIsMigrating)
    {
        AZ_Printf(__FUNCTION__, "we are on entity %s",
            GetEntity()->GetName().c_str());
    }
```
We will explore multiplayer functionality of these classes when we start writing multiplayer game logic in the next chapters.

## Overriding Components
Using the same steps as with controllers, you can also override the component to perform various logic that does not require write access to the component's data.

{{<tip>}}
An example of such logic is receiving a notification when a goal was scored on the server in order to update client's UI we created in Chapter 23, Interacting with UI in C++.
{{</tip>}}

1. Modify MyFirstNetworkComponent.AutoComponent.xml and enable OverrideComponent.
2. Build MyGem.Static. 
3. There will be build errors, since we did not provide the component in MyFirstNetworkComponent but by visiting MyFirstNetworkComponent.AutoComponent.h in the build folder, you will find that the stub has been updated to include both the controller and the component for you to start with.
4. Copy over the stubs to MyFirstNetworkComponent.h and MyFirstNetworkComponent.cpp.
5. Build the project. Everything should compile cleanly now.

Example 32.6. MyFirstNetworkComponent.h with a component
```c++
 #pragma once
 #include <Source/AutoGen/MyFirstNetworkComponent.AutoComponent.h>
 namespace MyGem
 {
 class MyFirstNetworkComponent
        : 
public MyFirstNetworkComponentBase
    {
 public:
        AZ_MULTIPLAYER_COMPONENT(MyGem::MyFirstNetworkComponent,
            s_myFirstNetworkComponentConcreteUuid,
            MyGem::MyFirstNetworkComponentBase);
 static void Reflect(AZ::ReflectContext* context);
 void OnInit() override;
 void OnActivate(Multiplayer::EntityIsMigrating) override;
 void OnDeactivate(Multiplayer::EntityIsMigrating) override;
 protected:
    };
 ...
 }
```
My First Network Component is a regular AZ::Component but derived through MyFirstNetwork ComponentBase. Much like the controller, OnActivate and OnDeactivate are to be used instead of using regular Activate and Deactivate AZ::Component methods.

Example 32.7. MyFirstNetworkComponent.cpp with a component
```
 #include <Multiplayer/MyFirstNetworkComponent.h>
 #include <AzCore/Serialization/SerializeContext.h>
 namespace MyGem
 {
 void MyFirstNetworkComponent::Reflect(AZ::ReflectContext* rc)
    {
 auto sc = azrtti_cast<AZ::SerializeContext*>(rc);
 if (sc)
        {
            sc->Class<MyFirstNetworkComponent,
                      MyFirstNetworkComponentBase>()
                ->Version(1);
        }
        MyFirstNetworkComponentBase::Reflect(rc);
    }
 void MyFirstNetworkComponent::OnInit()
    {
    }
 void MyFirstNetworkComponent::OnActivate(
        Multiplayer::EntityIsMigrating)
    {
 }
 void MyFirstNetworkComponent::OnDeactivate(
        Multiplayer::EntityIsMigrating)
    {
    }
 ...
 }
```
Reflect is a much simpler method in auto-components because all the reflection is done by code generated base classes, which can handle reflecting properties to the Editor and to scripting context.

##  Summary

{{<note>}}
The accompanying source code and assets for this chapter can be found on GitHub at:
https://github.com/AMZN-Olex/O3DEBookCode2111/tree/ch32_auto_components
{{</note>}}

We have gone over enough aspects of network components to get started with writing our first multiplayer game logic. The important ideas to remember are the following:
* O3DE Multiplayer gem provides a server-authoritative multiplayer system.
* XML definitions are used to generate network component base classes.
* Multiplayer Controllers have write access to component data.
* Multiplayer Components provide read-only access to component data
