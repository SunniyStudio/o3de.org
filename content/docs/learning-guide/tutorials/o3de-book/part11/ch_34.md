---
linkTitle: 第34章 简单的Player出生点
title: 第34章 简单的Player出生点
description: 第34章 简单的Player出生点
---
# 第34章 简单的Player出生点
##  Introduction

{{<note>}}
The accompanying source code and assets for this chapter can be found on GitHub at:
https://github.com/AMZN-Olex/O3DEBookCode2111/tree/ch34_player_spawner
{{</note>}}

Gem Multiplayer expects us to assign a player entity for each incoming connection on the server.

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_7.PNG)

IMultiplayerSpawner is an abstract interface defined at C:\git\o3de\Gems\Multiplayer\Code\Include\Multiplayer\IMultiplayerSpawner.h. It is up to us to implement it and supply it as an AZ::Interface. Its essential method is OnPlayerJoin:
```c++
Multiplayer::NetworkEntityHandle OnPlayerJoin(
uint64_t userId,
const Multiplayer::MultiplayerAgentDatum& agentDatum)
```

OnPlayerJoin expects back a NetworkEntityHandle which is a reference handle to a network entity. You can create a NetworkEntityHandle by passing a pointer to an AZ::Entity that has a Network Binding component.
```
NetworkEntityHandle(AZ::Entity*)
```
{{<tip>}}
Even though the name of the interface is a multiplayer spawner there is nothing in its API that forces our design choice of how to create our player entities. We can certainly spawn on demand, however, in this chapter I am going to keep it simple by pre-creating the player entity as a prefab on the level and when the Editor joins as a client, I will grab that prefab and return the entity from it.
{{</tip>}}

##  Design
I am going to create two new components: Chicken Spawn Component and Chicken Component. Chicken Spawn Component will be responsible for inheriting from IMultiplayerSpawner and implementing OnPlayerJoin. Chicken Component will be added to the main chicken entity and will report itself to Chicken Spawn Component on activation on the server. Chicken Spawn Component will then assign this entity to the player connection

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_8.PNG)

Chicken Notification Bus

Chicken component and Chicken Spawner component will communicate using a notification bus, Chicken NotificationBus.

Example 34.1. ChickenBus.h
```c++
 #pragma once
 #include <AzCore/Component/ComponentBus.h>
 namespace MyGem
 {
 class ChickenNotifications
        : public AZ::ComponentBus
    {
 public:
 ...
 virtual void OnChickenCreated(
            [[maybe_unused]] AZ::Entity* e) {}
    };
 using ChickenNotificationBus = AZ::EBus<ChickenNotifications>;
 }
```
When a chicken's prefab is spawned in the level, the chicken's entity will call OnChickenCreated that Chicken Spawner component will be expecting.

##  Chicken Component
This is going to be our first multiplayer controller implementation. We want the chicken component to register itself with Chicken Spawn Component only on the server as clients are not involved in player entity creation. We are server-authoritative after all!

The first step is to create the XML definition of an auto-component that overrides the controller.

Example 34.2. First ChickenComponent.AutoComponent.xml
```xml
<?xml version="1.0"?>
 <Component
   Name="ChickenComponent"
   Namespace="MyGem"
   OverrideComponent="false"
   OverrideController="true"
   OverrideInclude="Source/Multiplayer/ChickenComponent.h"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 </Component>
```

Next we follow the steps from Chapter 32, Auto Components to create ChickenComponent.h and ChickenComponent.cpp.

Example 34.3. ChickenComponent.h
```c++
 #pragma once
 #include <Source/AutoGen/ChickenComponent.AutoComponent.h>
 namespace MyGem
 {
 class ChickenComponentController
        : 
public ChickenComponentControllerBase
    {
 public:
        ChickenComponentController(ChickenComponent& parent);
 void OnActivate(Multiplayer::EntityIsMigrating) override;
 void OnDeactivate(Multiplayer::EntityIsMigrating) override {}
    };
 }
```
Example 34.4. ChickenComponent.cpp
```c++
 #include <Multiplayer/ChickenComponent.h>
 #include <MyGem/ChickenBus.h>
 namespace MyGem
 {
    ChickenComponentController::
      ChickenComponentController(ChickenComponent& p)
        : ChickenComponentControllerBase(p) {}
 void ChickenComponentController::OnActivate(
        Multiplayer::EntityIsMigrating)
    {
 if (!IsAuthority()) return;
        ChickenNotificationBus::Broadcast(
            &ChickenNotificationBus::Events::OnChickenCreated,
                GetEntity());
                }
 }
```
What is IsAuthority? This is a method from the base class MultiplayerController that is only true when the controller is on the authoritative server.
```c++
 //! Returns true if this controller has authority.
 //! @return boolean true if this controller has authority
 bool IsAuthority() const;
```

If the controller has write access to the component, then it is considered to have an authority over it. As a quick side, there are only two options for a controller. A controller can either have an authority, if it is on the server, or it can be an autonomous controller on the client that controls the chicken and can locally predict the movement of the chicken. Otherwise, no controller would be created for a component. We will tackle autonomous controllers when we implement multiplayer chicken movement.

{{<tip>}}
As you can see writing network components takes a lot less lines of code then a fully written AZ::Component. A lot of boilerplate is handled by the code generator.
{{</tip>}}

Chicken component goes on the root entity of the chicken structure we have in the level.

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_9.PNG)

## Chicken Spawn Component
Now that we have a chicken entity reporting its presence upon activation on the server, we need Chicken Spawn Component to receive it.

Example 34.5. Snippet from ChickenSpawnComponent.h
```c++
 class ChickenSpawnComponent
 : 
public AZ::Component
        , 
 public Multiplayer::IMultiplayerSpawner
        , 
 public ChickenNotificationBus::Handler
    {
 public:
 ...
 // ChickenNotificationBus
 void OnChickenCreated(AZ::Entity* e) override;
 // IMultiplayerSpawner overrides
        Multiplayer::NetworkEntityHandle OnPlayerJoin(
            uint64_t userId,
 const Multiplayer::MultiplayerAgentDatum&) override;
 ...
 private:
        AZ::Entity* m_chicken = nullptr;
```
ChickenSpawnComponent inherits from IMultiplayerSpawner and implements OnPlayerJoin.

OnChickenCreated saves the entity pointer and returns it via OnPlayerJoin when a client joins.

Example 34.6. Snippet from ChickenSpawnComponent.cpp
```c++
void ChickenSpawnComponent::OnChickenCreated(AZ::Entity* e)
    {
        m_chicken = e;
    }
    NetworkEntityHandle ChickenSpawnComponent::OnPlayerJoin(
        [[maybe_unused]] uint64_t userId,
 const Multiplayer::MultiplayerAgentDatum&)
    {
 return NetworkEntityHandle{ m_chicken };
    }
```
Chicken Spawn component is not a multiplayer component, so it can be placed directly on the level, for example under a new entity, Chicken Spawn.

## Creating Player Prefab
A player entity has to be a network entity, thus it goes inside a prefab, Chicken.prefab. Here are the steps to convert our current chicken into a multiplayer prefab.
1. For each chicken entity, add Net Binding and Network Transform components.
{{<note>}}
If you do not add both of these components, then those entities will not show up on clients at all. Net Binding component marks the entity as a network entity. Network Transform component specifies where to spawn the entity on clients and will update client position if the server moves the entity.
{{</note>}}

2. Add Local Prediction Player Input Component to the parent entity, Chicken. In the next chapter, it will be used to process player's input.

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_10.PNG)

3. Select all the chicken entities and create a prefab out of them.

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_11.PNG)

4. For better organization, I moved the prefab under Chicken Spawn entity.

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_12.PNG)

##  Summary

{{<note>}}
The accompanying source code and assets for this chapter can be found on GitHub at:
https://github.com/AMZN-Olex/O3DEBookCode2111/tree/ch34_player_spawner
{{</note>}}

With these changes, when you press CTRL+G, you will finally see your camera follow a chicken. Also you will see multiplayer entities show up when the Editor connects to the server.

{{<note>}}
It takes a few seconds for the server to start and the Editor to connect. If you can see your camera switch to follow a chicken, then everything is working as intended. Server waits for a client to join and then assigns it an entity to control that is specified by Chicken Spawn component.
{{</note>}}

{{<note>}}
The implementation in this chapter is very limited. It supports only one player on the server. In Chapter 39, Team Spawner, we will enhance Chicken Spawn Component to support multiple clients and have them join on different teams.
{{</note>}}

Example 34.7. Full code for ChickenSpawnComponent.h
```c++
 #pragma once
 #include <AzCore/Component/Component.h>
 #include <Multiplayer/IMultiplayerSpawner.h>
 #include <MyGem/ChickenBus.h>
 namespace MyGem
 {
 class ChickenSpawnComponent
        : 
public AZ::Component
        , 
        , 
public Multiplayer::IMultiplayerSpawner
 public ChickenNotificationBus::Handler
    {
 public:
        AZ_COMPONENT(ChickenSpawnComponent,
 "{814BAF21-10E4-4BE9-8380-C23B0EC27205}");
 static void Reflect(AZ::ReflectContext* rc);
 // AZ::Component interface implementation
 void Activate() override;
 void Deactivate() override;
 // ChickenNotificationBus
 void OnChickenCreated(AZ::Entity* e) override;
 // IMultiplayerSpawner overrides
        Multiplayer::NetworkEntityHandle OnPlayerJoin(
            uint64_t userId,
 const Multiplayer::MultiplayerAgentDatum&) override;
 void OnPlayerLeave(
            Multiplayer::ConstNetworkEntityHandle entityHandle,
 const Multiplayer::ReplicationSet& replicationSet,
            AzNetworking::DisconnectReason reason) override {}
 private:
        AZ::Entity* m_chicken = nullptr;
    };
 } // namespace MyGem
```

Example 34.8. Full code for ChickenSpawnComponent.cpp
```c++
 #include <ChickenSpawnComponent.h>
 #include <AzCore/Component/Entity.h>
 #include <AzCore/Interface/Interface.h>
 #include <AzCore/Serialization/EditContext.h>
 #include <Multiplayer/IMultiplayer.h>
  namespace MyGem
 {
 using namespace Multiplayer;
 void ChickenSpawnComponent::Reflect(AZ::ReflectContext* rc)
    {
 if (auto sc = azrtti_cast<AZ::SerializeContext*>(rc))
        {
            sc->Class<ChickenSpawnComponent, AZ::Component>()
                ->Version(1);
 if (AZ::EditContext* ec = sc->GetEditContext())
            {
 using namespace AZ::Edit;
                ec->Class<ChickenSpawnComponent>(
 "Chicken Spawn",
 "[Player controlled chickens]")
                    ->ClassElement(ClassElements::EditorData, "")
                    ->Attribute(
                        Attributes::AppearsInAddComponentMenu,
                        AZ_CRC_CE("Game"));
            }
        }
    }
 void ChickenSpawnComponent::Activate()
    {
        AZ::Interface<IMultiplayerSpawner>::Register(this);
        ChickenNotificationBus::Handler::BusConnect(GetEntityId());
    }
 void ChickenSpawnComponent::Deactivate()
    {
        ChickenNotificationBus::Handler::BusDisconnect();
        AZ::Interface<IMultiplayerSpawner>::Unregister(this);
    }
 void ChickenSpawnComponent::OnChickenCreated(AZ::Entity* e)
    {
        m_chicken = e;
    }
    NetworkEntityHandle ChickenSpawnComponent::OnPlayerJoin(
        [[maybe_unused]] uint64_t userId,
 const Multiplayer::MultiplayerAgentDatum&)
    {
 return NetworkEntityHandle{ m_chicken };
    }
 } // namespace MyGem
```

