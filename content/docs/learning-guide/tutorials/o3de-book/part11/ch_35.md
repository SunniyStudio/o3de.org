---
linkTitle: 第35章 多人游戏输入控制
title: 第35章 多人游戏输入控制
description: 第35章 多人游戏输入控制
---
# 第35章 多人游戏输入控制
##  Introduction

{{<note>}}
The accompanying source code and assets for this chapter can be found on GitHub at:
https://github.com/AMZN-Olex/O3DEBookCode2111/tree/ch35_multiplayer_input
{{</note>}}

It may appear that our chicken is already moving on its own. After all, it does move in the Editor. However, if you were to launch a standalone server, you would notice that the chicken entity is only moving on the client. We are still using single player input component that is directly controlling the position of the entity.

So far the server has no idea that you are issuing input.

{{<note>}}
Out of all multiplayer topics, this chapter will be the most complicated as it involves re-writing the old single player input logic into a system that supports local prediction, correction and server side roll back.
The good news is that the actual logic is very similar to Chapter 18, Character Movement. It just needs to be placed under different methods. As I go through in this chapter, I will present single player and multiplayer implementations side by side.
{{</note>}}

## Chicken Movement Component
This chapter will create a new component, ChickenMovementComponent, to replace ChickenControllerComponent. It will be a multiplayer component that can capture and process input in such a manner that Multiplayer gem can locally predict the movement of the chicken without us doing any extra work.

As it is with multiplayer components, we will need three (3) new files.

Example 35.1. Additions to Gems\MyGem\Code\mygem_files.cmake
```
set(FILES
  ...
  # new
  Source/AutoGen/ChickenMovementComponent.AutoComponent.xml
  Source/Multiplayer/ChickenMovementComponent.h
  Source/Multiplayer/ChickenMovementComponent.cpp
)
```

## XML Definition
XML definition of ChickenMovementComponent will have a number of new elements. This section will cover each new type:
* Component Relation
* Archetype Property
* Network Input

## Component Relation
A multiplayer controller can declare a dependency on another component's controller on the same entity. This will code generate a getter method. For example, we will need to use the controller of NetworkCharacter component in order to move our multiplayer chicken. The API for that is NetworkCharacterComponentController::TryMoveWithVelocity. Instead of trying to get the entity, then Network Character component and then fight the API to get to controller of another entity, we will declare a Component Relation.
```xml
<ComponentRelation Constraint="Required" HasController="true"
Name="NetworkCharacterComponent" Namespace="Multiplayer"
Include="Multiplayer/Components/NetworkCharacterComponent.h"/>
```

That will allow us to call TryMoveWithVelocity from Chicken Movement Component Controller direcly.
```
GetNetworkCharacterComponentController()->
TryMoveWithVelocity(m_velocity, deltaTime);
```
{{<note>}}
This is similar to providing GetRequiredServices() method on an AZ::Component but with an extra benefit of receiving a helpful getter method.
{{</note>}}

## Archetype Property
In Chapter 18, Character Movement, ChickenControllerComponent exposed Speed, Turn Speed and Gravity settings to the Editor. We had to reflect it ourselves.
```c++
class ChickenControllerComponent
 {
 float m_speed = 6.f;
 float m_turnSpeed = 0.005.f;
 float m_gravity = -9.8f;
 //...
    ->DataElement(nullptr,
        &ChickenControllerComponent::m_turnSpeed,
 "Turn Speed", "Chicken's turning speed")
 /// and so on
```
With Archetype Property we can save the effort and use code generator instead.
```xml
 <ArchetypeProperty Type="float"  Name="WalkSpeed"
 Init="6.0f"   ExposeToEditor="true" />
 <ArchetypeProperty Type="float"  Name="TurnSpeed"
 Init="0.005f" ExposeToEditor="true" />
 <ArchetypeProperty Type="float"  Name="Gravity"
 Init="-9.8f"  ExposeToEditor="true" />
```
Archetype Property will do all the work of reflecting the details to the Editor for us.

### Network Input
In Chapter 18, Character Movement, ChickenControllerComponent was responsible for processing player input and was storing it in ChickenInput structure
```c++
 class ChickenInput
    {
 public:
   float m_forwardAxis = 0;
   float m_strafeAxis = 0;
   float m_viewYaw = 0;
    };
```
With multiplayer input, we declare these as NetworkInput's.
```xml
<NetworkInput Type="float"   Name="ForwardAxis" Init="0.0f" />
<NetworkInput Type="float"   Name="StrafeAxis"  Init="0.0f" />
<NetworkInput Type="float"   Name="ViewYaw" Init="0.0f" />
<NetworkInput Type="uint8_t" Name="ResetCount"  Init="0"/>
```
{{<note>}}
Reset Count is a special variable that is incremented any time the entity moves in an usual way, such as teleporting to a new location or stepping on a launch pad. Without this counter, local prediction will have issues with sudden movement and state changes.
{{</note>}}

{{<note>}}
Multiplayer components with a Network Input require Local Prediction Player Input component on the entity.
{{</note>}}

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_13.PNG)

##  Create Input
When you add a Network Input to a multiplayer component, code generator will add two (2) new methods for you to implement.
```c++
 //! Common input creation logic for the NetworkInput.
 //! Fill out the input struct and the MultiplayerInputDriver
 //! will send the input data over the network to ensure
 //! it's processed.
 //! @param input  input structure which to store input data
 //!               for sending to the authority
 //! @param deltaTime amount of time to integrate
 //!                  the provided inputs over
 void CreateInput(
            Multiplayer::NetworkInput& input,
 float deltaTime) override;
  //! Common input processing logic for the NetworkInput.
 //! @param input  input structure to process
 //! @param deltaTime amount of time to integrate the
 //!                  provided inputs over
 void ProcessInput(
            Multiplayer::NetworkInput& input,
 float deltaTime) override;
```
Creation of input occurs on clients on player owned entities, otherwise known as Autonomous entities.

Their task is to collect player's input and send it to the server.

Figure 35.1. Sending Player Input to the Server

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_14.PNG)

1. UpdateAutonomous gets called at a specified client input rate. You can control this rate with a Multiplayer gem variable, cl_InputRateMs. The default is to collect input every 33 milliseconds.
```c++
AZ_CVAR(AZ::TimeMs, cl_InputRateMs, AZ::TimeMs{ 33 }, nullptr,
AZ::ConsoleFunctorFlags::Null,
"Rate at which to sample and process client inputs");
```
2. NetworkInputArray is a container with the current input and previous seven (7) inputs. Our job is to collect the current input values. Local Prediction Player Input component will populate older entries on our behalf from the local input history.

Why are we sending seven (7) older inputs each time? This is because input is sent using an un reliable remote procedure call. Here is a snippet from XML definition of LocalPredictionPlayerInputComponent from Multiplayer gem, where IsReliable is set to false.

Example 35.2. LocalPredictionPlayerInputComponent.AutoComponent.xml
```xml
<RemoteProcedure Name="SendClientInput" InvokeFrom="Autonomous"
 HandleOn="Authority" IsPublic="true" IsReliable="false"
 GenerateEventBindings="false"
                 Description="Client to server move / input RPC">
  <Param Type="Multiplayer::NetworkInputArray" Name="inputArray" />
  <Param Type="AZ::HashValue32" Name="stateHash" />
</RemoteProcedure>
```
Multiplayer replication uses UDP1 protocol, which is unreliable by design to achieve faster delivery and reduce stalls. Multiplayer gem overcomes this by sending multiple inputs. This means we can lose up to seven (7) inputs and still be able to recover. Given client input rate of 33 milliseconds that allows for almost a quarter of a second recovery time (231 milliseconds) before the server fails to receive all input. This is sufficient for majority of real world network scenarios
3. From Network Input Array, the multiplayer system will grab the first item (at zeroth index) as NetworkInput and pass it to all the relevant multiplayer components.
4. CreateInput's job is to collect the input for the last input time period.
5. ProcessInput is applied on the client immediately. This is the local prediction step, where the client    guesses where the input will take it. If the server disagrees, the client will be corrected later.
6. The input is then sent to the server.

{{<note>}}
This was a behind-the-scenes look at the input processing logic. Users only need to worry about implementing CreateInput and ProcessInput methods. The rest will be done by the Multiplayer gem.
{{</note>}}

Here is side by side comparison between single player create input and multiplayer create input methods
Example 35.3. Single-player create input logic
```c++
ChickenInput ChickenControllerComponent::CreateInput()
{
  ChickenInput input;
  input.m_forwardAxis = m_forward;
  input.m_strafeAxis = m_strafe;
  input.m_viewYaw = m_yaw;
  return input;
}
```
And here is the multiplayer one

Example 35.4. Multiplayer create input logic

```c++
 void ChickenMovementComponentController::CreateInput(
        Multiplayer::NetworkInput& input,
        [[maybe_unused]] float deltaTime)
    {
 auto chickenInput = input.FindComponentInput<
            ChickenMovementComponentNetworkInput>();
             chickenInput->m_forwardAxis = m_forward;
        chickenInput->m_strafeAxis = m_strafe;
        chickenInput->m_viewYaw = m_yaw;
        chickenInput->m_resetCount =
          GetNetworkTransformComponentController()->GetResetCount();
    }
```
ChickenMovementComponentNetworkInput was generated for us based on the XML definition that listed all the network inputs.

Example 35.5. Snippet from ChickenMovementComponent.AutoComponent.h
```c++
class ChickenMovementComponentNetworkInput
    : 
public Multiplayer::IMultiplayerComponentInput
 {
 public:
 ...
 float m_forwardAxis = float(0.0f);
 float m_strafeAxis = float(0.0f);
 float m_viewYaw = float(0.0f);
    uint8_t m_resetCount = uint8_t(0);
 };
```
Overall, the only difference from the single-player input is that we have a special input reset counter to handle special movement cases but otherwise they are same.

## Process Input
Once the input arrives to the server, it will be applied using logic written in ProcessInput.

Figure 35.2. Processing Input on the Server

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_15.PNG)

1. HandleSendClientInput is the handle for the remote procedure.
2. There is no creation of an input, since this is happening on the server. ProcessInput gets called for    each relevant multiplayer component that creates input on clients.
3. If a mismatch is found between client and server results, then a correction is sent back to the client using    an unreliable remote procedure from Local Prediction Player Input component.












