---
linkTitle: 第37章 移除与生成
title: 第37章 移除与生成
description: 第37章 移除与生成
---
# 第37章 移除与生成
## 介绍

{{<note>}}
本章随附的源代码和资源可以在 GitHub 上找到：
https://github.com/AMZN-Olex/O3DEBookCode2111/tree/ch37_removal_and_spawning
{{</note>}}

第 36 章 多人游戏物理特性 重新实现了目标检测，以使用服务器授权机制。

但是，足球并没有被放回足球场的中间。在本章中，我将向您展示如何通过删除旧球并生成一个新球来做到这一点。

图 37.1.新 Ball Spawner 的设计

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_18.PNG)

1. 以前，足球是直接在 Editor 中放置在水平面上的。这一次，具有新 Ball Spawner 组件的新实体将在实体激活时执行此作。
2. 我在第 11 章 预制件简介中介绍了如何生成预制件。
3. 生成 Network_Ball.prefab 后，Ball 组件将使用 OnBallSpawned 回调生成器。生成器将保存实体指针以管理其生命周期。
4. 当进球后需要重新生成球时，新的 EBus 请求将要求生成器使用 RespawnBall 重新生成球。
5. MarkForRemoval 是本章中介绍的新多人游戏 Gem API。它能够删除网络实体。

{{<note>}}
不得直接停用和删除网络实体。必须使用 Network Entity Manager 中的 MarkForRemoval 方法，如本章后面所示。
{{</note>}}

6. 游戏循环通过生成一个新球来继续

## 球组件
通过创建 Ball 组件并将其放置在 Ball 实体上，我们可以在生成后在关卡中激活新 Ball 时发送事件。由于生成和删除是在服务器上启动的，因此此多人游戏组件需要一个控制器。在服务器上创建新的网络实体时，多人游戏系统将负责在客户端上创建实体。在服务器上删除网络实体时也是如此。

例 37.1.BallComponent.AutoComponent.xml
```xml
<?xml version="1.0"?>
 <Component
 Name="BallComponent"
 Namespace="MyGem"
 OverrideComponent="false"
 OverrideController="true"
 OverrideInclude="Multiplayer/BallComponent.h"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 </Component>
```
当 Ball 组件的 controller 在其实体激活时，会发出通知。
```c++
void BallComponentController::OnActivate(
        Multiplayer::EntityIsMigrating)
    {
        BallNotificationBus::Broadcast(
            &BallNotificationBus::Events::OnBallSpawned,
            GetEntity());
    }
```
这就是 Ball Component 所做的全部工作。

##  Ball Spawner 组件
我们已经在第 11 章 预制件简介中实现了一个生成器。这一次，我们将在 Multiplayer 组件中执行此作，该组件会删除旧实体并生成新实体。

为了循环遍历足球实体的引用，Ball Spawner 组件会将其指针保存在一个小的环形缓冲区中。

```c++
AZStd::ring_buffer<AZ::Entity*> m_balls;
m_balls.set_capacity(2);
```

{{<tip>}}
环形缓冲区是具有可配置常量大小的圆形容器。新条目将首先覆盖最旧的元素。
{{</tip>}}

## 删除网络实体

{{<tip>}}
不得通过直接停用网络实体来删除网络实体。网络实体在幕后有许多系统处理其状态和更新。必须使用 MarkForRemoval 从 INetworkEntityManager 接口请求删除它们。
```c++
//! Marks the specified entity for removal and deletion.
//! @param entityHandle the entity to remove and delete
void MarkForRemoval(const ConstNetworkEntityHandle& h);
```
{{</tip>}}

Multiplayer::ConstNetworkEntityHandle 是引用网络实体的包装器。可以通过为其提供指向网络实体的指针来构造它。

{{<note>}}
网络实体是具有 Network Binding 组件的实体。
以下是使用指向其实体的指针删除旧球的方法。
{{</note>}}
```c++
AZ::Entity* previousBall = m_balls.back();
Multiplayer::ConstNetworkEntityHandle oldBall(previousBall);
AZ::Interface<IMultiplayer>::Get()->
GetNetworkEntityManager()->MarkForRemoval(oldBall);
```

{{<note>}}
标记的实体不会立即消失，可能需要另一个游戏时钟周期才能清理和删除实体和各种网络资源。
{{</note>}}

为了禁用与旧球的任何不需要的交互，我们将停用物理，以便旧球不再激活目标触发器。
```c++
using RigidBus = Physics::RigidBodyRequestBus;
RigidBus::Event(previousBall->GetId(),
&RigidBus::Events::DisablePhysics);
```

## 生成网络实体
生成网络实体使用的方法与第 11 章 预制件简介中的方法相同，但有一个有趣的细节。我们将为要生成的球预制件指定一个 Spawnable 字段。

图 37.2.具有预制件的 Ball Spawner

![](/images/learning-guide/tutorials/o3de-book/Part11/o3de_book_11_19.PNG)

















